// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package handlers

import (
	context "context"
	areas "github.com/ONSdigital/dp-api-clients-go/v2/areas"
	healthcheck "github.com/ONSdigital/dp-healthcheck/healthcheck"
	model "github.com/ONSdigital/dp-renderer/model"
	io "io"
	"sync"
)

// Ensure, that AreaApiClientMock does implement AreaApiClient.
// If this is not the case, regenerate this file with moq.
var _ AreaApiClient = &AreaApiClientMock{}

// AreaApiClientMock is a mock implementation of AreaApiClient.
//
// 	func TestSomethingThatUsesAreaApiClient(t *testing.T) {
//
// 		// make and configure a mocked AreaApiClient
// 		mockedAreaApiClient := &AreaApiClientMock{
// 			CheckerFunc: func(ctx context.Context, check *healthcheck.CheckState) error {
// 				panic("mock out the Checker method")
// 			},
// 			GetAncestorsFunc: func(areaId string) ([]areas.Ancestor, error) {
// 				panic("mock out the GetAncestors method")
// 			},
// 			GetAreaFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, areaID string, acceptLang string) (areas.AreaDetails, error) {
// 				panic("mock out the GetArea method")
// 			},
// 			GetRelationsFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, areaID string, acceptLang string) ([]areas.Relation, error) {
// 				panic("mock out the GetRelations method")
// 			},
// 		}
//
// 		// use mockedAreaApiClient in code that requires AreaApiClient
// 		// and then make assertions.
//
// 	}
type AreaApiClientMock struct {
	// CheckerFunc mocks the Checker method.
	CheckerFunc func(ctx context.Context, check *healthcheck.CheckState) error

	// GetAncestorsFunc mocks the GetAncestors method.
	GetAncestorsFunc func(areaId string) ([]areas.Ancestor, error)

	// GetAreaFunc mocks the GetArea method.
	GetAreaFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, areaID string, acceptLang string) (areas.AreaDetails, error)

	// GetRelationsFunc mocks the GetRelations method.
	GetRelationsFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, areaID string, acceptLang string) ([]areas.Relation, error)

	// calls tracks calls to the methods.
	calls struct {
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Check is the check argument value.
			Check *healthcheck.CheckState
		}
		// GetAncestors holds details about calls to the GetAncestors method.
		GetAncestors []struct {
			// AreaId is the areaId argument value.
			AreaId string
		}
		// GetArea holds details about calls to the GetArea method.
		GetArea []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// AreaID is the areaID argument value.
			AreaID string
			// AcceptLang is the acceptLang argument value.
			AcceptLang string
		}
		// GetRelations holds details about calls to the GetRelations method.
		GetRelations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// AreaID is the areaID argument value.
			AreaID string
			// AcceptLang is the acceptLang argument value.
			AcceptLang string
		}
	}
	lockChecker      sync.RWMutex
	lockGetAncestors sync.RWMutex
	lockGetArea      sync.RWMutex
	lockGetRelations sync.RWMutex
}

// Checker calls CheckerFunc.
func (mock *AreaApiClientMock) Checker(ctx context.Context, check *healthcheck.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("AreaApiClientMock.CheckerFunc: method is nil but AreaApiClient.Checker was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Check *healthcheck.CheckState
	}{
		Ctx:   ctx,
		Check: check,
	}
	mock.lockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	mock.lockChecker.Unlock()
	return mock.CheckerFunc(ctx, check)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//     len(mockedAreaApiClient.CheckerCalls())
func (mock *AreaApiClientMock) CheckerCalls() []struct {
	Ctx   context.Context
	Check *healthcheck.CheckState
} {
	var calls []struct {
		Ctx   context.Context
		Check *healthcheck.CheckState
	}
	mock.lockChecker.RLock()
	calls = mock.calls.Checker
	mock.lockChecker.RUnlock()
	return calls
}

// GetAncestors calls GetAncestorsFunc.
func (mock *AreaApiClientMock) GetAncestors(areaId string) ([]areas.Ancestor, error) {
	if mock.GetAncestorsFunc == nil {
		panic("AreaApiClientMock.GetAncestorsFunc: method is nil but AreaApiClient.GetAncestors was just called")
	}
	callInfo := struct {
		AreaId string
	}{
		AreaId: areaId,
	}
	mock.lockGetAncestors.Lock()
	mock.calls.GetAncestors = append(mock.calls.GetAncestors, callInfo)
	mock.lockGetAncestors.Unlock()
	return mock.GetAncestorsFunc(areaId)
}

// GetAncestorsCalls gets all the calls that were made to GetAncestors.
// Check the length with:
//     len(mockedAreaApiClient.GetAncestorsCalls())
func (mock *AreaApiClientMock) GetAncestorsCalls() []struct {
	AreaId string
} {
	var calls []struct {
		AreaId string
	}
	mock.lockGetAncestors.RLock()
	calls = mock.calls.GetAncestors
	mock.lockGetAncestors.RUnlock()
	return calls
}

// GetArea calls GetAreaFunc.
func (mock *AreaApiClientMock) GetArea(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, areaID string, acceptLang string) (areas.AreaDetails, error) {
	if mock.GetAreaFunc == nil {
		panic("AreaApiClientMock.GetAreaFunc: method is nil but AreaApiClient.GetArea was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		AreaID           string
		AcceptLang       string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		AreaID:           areaID,
		AcceptLang:       acceptLang,
	}
	mock.lockGetArea.Lock()
	mock.calls.GetArea = append(mock.calls.GetArea, callInfo)
	mock.lockGetArea.Unlock()
	return mock.GetAreaFunc(ctx, userAuthToken, serviceAuthToken, collectionID, areaID, acceptLang)
}

// GetAreaCalls gets all the calls that were made to GetArea.
// Check the length with:
//     len(mockedAreaApiClient.GetAreaCalls())
func (mock *AreaApiClientMock) GetAreaCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	AreaID           string
	AcceptLang       string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		AreaID           string
		AcceptLang       string
	}
	mock.lockGetArea.RLock()
	calls = mock.calls.GetArea
	mock.lockGetArea.RUnlock()
	return calls
}

// GetRelations calls GetRelationsFunc.
func (mock *AreaApiClientMock) GetRelations(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, areaID string, acceptLang string) ([]areas.Relation, error) {
	if mock.GetRelationsFunc == nil {
		panic("AreaApiClientMock.GetRelationsFunc: method is nil but AreaApiClient.GetRelations was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		AreaID           string
		AcceptLang       string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		AreaID:           areaID,
		AcceptLang:       acceptLang,
	}
	mock.lockGetRelations.Lock()
	mock.calls.GetRelations = append(mock.calls.GetRelations, callInfo)
	mock.lockGetRelations.Unlock()
	return mock.GetRelationsFunc(ctx, userAuthToken, serviceAuthToken, collectionID, areaID, acceptLang)
}

// GetRelationsCalls gets all the calls that were made to GetRelations.
// Check the length with:
//     len(mockedAreaApiClient.GetRelationsCalls())
func (mock *AreaApiClientMock) GetRelationsCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	AreaID           string
	AcceptLang       string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		AreaID           string
		AcceptLang       string
	}
	mock.lockGetRelations.RLock()
	calls = mock.calls.GetRelations
	mock.lockGetRelations.RUnlock()
	return calls
}

// Ensure, that RenderClientMock does implement RenderClient.
// If this is not the case, regenerate this file with moq.
var _ RenderClient = &RenderClientMock{}

// RenderClientMock is a mock implementation of RenderClient.
//
// 	func TestSomethingThatUsesRenderClient(t *testing.T) {
//
// 		// make and configure a mocked RenderClient
// 		mockedRenderClient := &RenderClientMock{
// 			BuildPageFunc: func(w io.Writer, pageModel interface{}, templateName string)  {
// 				panic("mock out the BuildPage method")
// 			},
// 			NewBasePageModelFunc: func() model.Page {
// 				panic("mock out the NewBasePageModel method")
// 			},
// 		}
//
// 		// use mockedRenderClient in code that requires RenderClient
// 		// and then make assertions.
//
// 	}
type RenderClientMock struct {
	// BuildPageFunc mocks the BuildPage method.
	BuildPageFunc func(w io.Writer, pageModel interface{}, templateName string)

	// NewBasePageModelFunc mocks the NewBasePageModel method.
	NewBasePageModelFunc func() model.Page

	// calls tracks calls to the methods.
	calls struct {
		// BuildPage holds details about calls to the BuildPage method.
		BuildPage []struct {
			// W is the w argument value.
			W io.Writer
			// PageModel is the pageModel argument value.
			PageModel interface{}
			// TemplateName is the templateName argument value.
			TemplateName string
		}
		// NewBasePageModel holds details about calls to the NewBasePageModel method.
		NewBasePageModel []struct {
		}
	}
	lockBuildPage        sync.RWMutex
	lockNewBasePageModel sync.RWMutex
}

// BuildPage calls BuildPageFunc.
func (mock *RenderClientMock) BuildPage(w io.Writer, pageModel interface{}, templateName string) {
	if mock.BuildPageFunc == nil {
		panic("RenderClientMock.BuildPageFunc: method is nil but RenderClient.BuildPage was just called")
	}
	callInfo := struct {
		W            io.Writer
		PageModel    interface{}
		TemplateName string
	}{
		W:            w,
		PageModel:    pageModel,
		TemplateName: templateName,
	}
	mock.lockBuildPage.Lock()
	mock.calls.BuildPage = append(mock.calls.BuildPage, callInfo)
	mock.lockBuildPage.Unlock()
	mock.BuildPageFunc(w, pageModel, templateName)
}

// BuildPageCalls gets all the calls that were made to BuildPage.
// Check the length with:
//     len(mockedRenderClient.BuildPageCalls())
func (mock *RenderClientMock) BuildPageCalls() []struct {
	W            io.Writer
	PageModel    interface{}
	TemplateName string
} {
	var calls []struct {
		W            io.Writer
		PageModel    interface{}
		TemplateName string
	}
	mock.lockBuildPage.RLock()
	calls = mock.calls.BuildPage
	mock.lockBuildPage.RUnlock()
	return calls
}

// NewBasePageModel calls NewBasePageModelFunc.
func (mock *RenderClientMock) NewBasePageModel() model.Page {
	if mock.NewBasePageModelFunc == nil {
		panic("RenderClientMock.NewBasePageModelFunc: method is nil but RenderClient.NewBasePageModel was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNewBasePageModel.Lock()
	mock.calls.NewBasePageModel = append(mock.calls.NewBasePageModel, callInfo)
	mock.lockNewBasePageModel.Unlock()
	return mock.NewBasePageModelFunc()
}

// NewBasePageModelCalls gets all the calls that were made to NewBasePageModel.
// Check the length with:
//     len(mockedRenderClient.NewBasePageModelCalls())
func (mock *RenderClientMock) NewBasePageModelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNewBasePageModel.RLock()
	calls = mock.calls.NewBasePageModel
	mock.lockNewBasePageModel.RUnlock()
	return calls
}

// Ensure, that RendererClientMock does implement RendererClient.
// If this is not the case, regenerate this file with moq.
var _ RendererClient = &RendererClientMock{}

// RendererClientMock is a mock implementation of RendererClient.
//
// 	func TestSomethingThatUsesRendererClient(t *testing.T) {
//
// 		// make and configure a mocked RendererClient
// 		mockedRendererClient := &RendererClientMock{
// 			CheckerFunc: func(ctx context.Context, check *healthcheck.CheckState) error {
// 				panic("mock out the Checker method")
// 			},
// 			DoFunc: func(s string, bytes []byte) ([]byte, error) {
// 				panic("mock out the Do method")
// 			},
// 		}
//
// 		// use mockedRendererClient in code that requires RendererClient
// 		// and then make assertions.
//
// 	}
type RendererClientMock struct {
	// CheckerFunc mocks the Checker method.
	CheckerFunc func(ctx context.Context, check *healthcheck.CheckState) error

	// DoFunc mocks the Do method.
	DoFunc func(s string, bytes []byte) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Check is the check argument value.
			Check *healthcheck.CheckState
		}
		// Do holds details about calls to the Do method.
		Do []struct {
			// S is the s argument value.
			S string
			// Bytes is the bytes argument value.
			Bytes []byte
		}
	}
	lockChecker sync.RWMutex
	lockDo      sync.RWMutex
}

// Checker calls CheckerFunc.
func (mock *RendererClientMock) Checker(ctx context.Context, check *healthcheck.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("RendererClientMock.CheckerFunc: method is nil but RendererClient.Checker was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Check *healthcheck.CheckState
	}{
		Ctx:   ctx,
		Check: check,
	}
	mock.lockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	mock.lockChecker.Unlock()
	return mock.CheckerFunc(ctx, check)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//     len(mockedRendererClient.CheckerCalls())
func (mock *RendererClientMock) CheckerCalls() []struct {
	Ctx   context.Context
	Check *healthcheck.CheckState
} {
	var calls []struct {
		Ctx   context.Context
		Check *healthcheck.CheckState
	}
	mock.lockChecker.RLock()
	calls = mock.calls.Checker
	mock.lockChecker.RUnlock()
	return calls
}

// Do calls DoFunc.
func (mock *RendererClientMock) Do(s string, bytes []byte) ([]byte, error) {
	if mock.DoFunc == nil {
		panic("RendererClientMock.DoFunc: method is nil but RendererClient.Do was just called")
	}
	callInfo := struct {
		S     string
		Bytes []byte
	}{
		S:     s,
		Bytes: bytes,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(s, bytes)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//     len(mockedRendererClient.DoCalls())
func (mock *RendererClientMock) DoCalls() []struct {
	S     string
	Bytes []byte
} {
	var calls []struct {
		S     string
		Bytes []byte
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}
